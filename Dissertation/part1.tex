\chapter{Введение} \label{chapt1}
\section{Постановка задачи}
Задачи хранения и обработки большого числа данных встречаются повсеместно. При этом хочется делать это эффективно и быстро. 

Представим себе торговую площадку, каждый товар обладает рядом характеристик непрерывных или дискретных, как например на рисунках~\ref{img:market_example1},~\ref{img:market_example2},~\ref{img:market_example3}.

\begin{figure}[ht] 
	\centering
	\includegraphics [scale=0.4] {market_example1}
	\caption{Продажа электроники}
	\label{img:market_example1}
\end{figure}

\begin{figure}[ht] 
	\centering
	\includegraphics [scale=0.5] {market_example2}
	\caption{Продажа автомобилей}
	\label{img:market_example2}
\end{figure}

\begin{figure}[ht] 
	\centering
	\includegraphics [scale=0.5] {market_example3}
	\caption{Продажа недвижимости}
	\label{img:market_example3}
\end{figure}

Правильно организованная работа с данными увеличивает скорость выполнения запросов и позволяет экономить на оборудовании. Для этого стоит выбрать правильную структуру данных для хранения. Далее будут рассмотрены типы индексов, используемые в современных СУБД и проведено их сравнение. 

\chapter{Анализ предметной области} \label{chapt2}
\section{Типы индексов}
\subsubsection{B-Tree}
\begin{figure}[ht] 
	\centering
	\includegraphics [scale=0.5] {btree}
	\caption{Схематичный пример индекса по одному полю с целочисленными ключами}
	\label{img:btree}
\end{figure}
Для хранения данных в отсортированном виде используется B-Tree. Чтобы примерно представить себе работу можно вспомнить обычное бинарное дерево (в плане логарифмического времени поиска и структуры) . Однако в данном случае всё устроено сложнее: дерево сбалансировано и сильно ветвистое --- каждый узел обычно имеет более двух потомков ~\ref{img:btree}.

Поддерживаются операторы сравнения и равенство. Однако для поиска по многомерным структурам данных данный тип индекса не будет подходить --- фильтром можно будет использовать лишь для одного ключа, для фильтрации по другим характеристикам придется прибегнуть к перебору, что сильно снижает скорость запроса.

Тем не менее для большинства задач B-дерево всё-таки является хорошим вариантом. B-Tree можно назвать самым популярным индексом, использующимся в большинстве современных СУБД как реляционных, так и нереляционных.
Существует много модификаций B-Tree: B+Tree (используется в CouchDB, MongoDB), SB-Tree (OrientDB).

\subsubsection{Hash}
Hash--индекс работает не с индексируемыми ключами, а с их хэшами. Идея хеширования состоит в том, чтобы значению любого типа данных сопоставить некоторую битовую последовательность фиксированной длины. Такое сопоставление называют хеш-функцией. Полученное значение можно использовать как индекс обычного массива, куда и складывать ссылки на строки таблицы. 

Это следующий по популярности индекс. Главным недостатком является то, что в запросах поддерживается только операция равенства. Кроме того, возникают коллизии (когда одному хэшу соответствует несколько значений) и трудности с хранением null--значений. 

В отличие от других вариантов хранится не само значение, а его хэш, что делает этот индекс компактным и быстрым.

\subsubsection{LSM-Tree}
Вместо B-дерева данные можно хранить в структуре, называемой LSM-деревом --- \textit{Log-structured merge-tree}.
Ключевым отличием является то, что в узлах дерева хранятся не сами данные, а операции с ними.

\begin{figure}[ht] 
	\centering
	\includegraphics [scale=0.3] {lsm_tree_ops}
	\caption{Устройство одного уровня в LSM-дереве}
	\label{img:lsm_tree_ops}
\end{figure}

При этом если B-дерево целиком хранится на диске, то LSM-Tree допускает возможность частичного хранения в оперативной памяти --- L0-уровень (zero level). Все операции вставки делаются в L0, как только место в оперативной памяти заканчивается, данные начинают сбрасываться на диск.

Считается, что LSM-деревья работают быстрее для частых вставок и редких чтений, в отличие от B-деревьев.

\subsubsection{Inverted index}
Индекс, использующаяся для полнотекстового поиска. Содержит список всех уникальных слов и ссылки на документы, в которых эти слова встретились. При этом 

Полнотекстовые запросы выполняют лингвистический поиск в текстовых данных путем обработки слов и фраз в соответствии с правилами конкретного языка: разбиение на слова, отсекание окончаний, выбор однокоренных слов и т.д. Отдельными задачами при полнотекстовом поиске являются ранжирование результатов запроса и исключение ненужных слов.

Реализации полнотекстового поиска варьируются в различных СУБД. Инвертированный индекс используется в Microsoft SQL Server, MySQL, OrientDB и поисковом движке Elasticsearch.

Обобщением данного типа индекса является \textit{GIN} (Generalized Inverted Index),  реализованный в PostgreSQL.
Кроме полнотекстового поиска, является подходящим для индексирования массивов и JSON. Обобщенным он называется, потому что операция над индексируемым объектом задается отдельно в отличие от, например, B-Tree, где все операции сравнения уже заданы. В качестве операция могут использоваться такие как <<содержит>>, <<пересекается>>, <<содержится>>.

Количество текстовой информации, окружающей нас огромно: новости, книги, письма и т.д. Для индексирования содержимого этот тип индекса является подходящим. Однако работа с текстом не входит в поставленную задачу. 

\subsection{Пространственные индексы}
Большинство современных СУБД имеют типы, предназначенные для работы с пространственными типами данных: точки, прямые, окружности и другие геометрические объекты. Для данных объектов используются свои стратегии индексирования.

Известными решениями является использование пространственной сетки (spatial grid), дерева квадрантов (quadtree) и R-Tree.

Данные индексы используются графовыми базами данных (Neo4j, AllegroGrath), однако существуют специальные дополнения и расширения для известных СУБД, но предназначенные для обработки исключительно пространственной информации --- PostGIS, Oracle Spatial, GeoAPI в Redis.

\subsubsection{R-Tree}
\begin{figure}[ht] 
	\centering
	\includegraphics [scale=0.5] {rtree}
	\caption{Пример организации хранения данных в R-Tree}
	\label{img:rtree}
\end{figure}

Эта структура данных разбивает многомерное пространство на множество иерархически вложенных и, возможно, пересекающихся, прямоугольников и гиперкубов (для многомерных структур)~\ref{img:rtree}.

Подходит для поиска объектов в 2-3--мерном пространстве. Идея лежащая в основе индекса --- группировка объектов в зависимости от расстояния друг до друга. Это ускоряет поиск, однако происходит потеря точности, и возвращенный результат может не быть абсолютно точным.

Данный тип индекса поддерживается некоторыми движками СУБД MariaDB (SPATIAL INDEX), PostgreSQL (RTREE), Oracle.

Существует несколько модификаций R-Tree: R+-Tree, R*-Tree. Обобщением R-Tree является X-Tree, который позволяет индексировать данные произвольных размерностей. 

Другое обобщение \textit{GiST (The Generalized Search Tree)} --- обобщенное дерево поиска. Реализовано в PostgreSQL и подобно GIN поддерживает индексирование произвольной информации (геоданные, тексты, изображения и т.д.) с использованием операций <<принадлежит>>, <<содержит>>, <<совпадает>>, <<соответствует>>.

\subsubsection{UB-Tree (Universal B-Tree)}
Индекс используемый для хранения многомерных данных в одномерной структуре. К каждому значению применяется преобразование Мортона, заключающееся в чередовании двоичных цифр координатных значений, полученный результат называется Z-последовательностью (Z-order curve). Для обработки одномерных данных используется обычное B-дерево.

\begin{figure}[ht] 
	\centering
	\includegraphics [scale=0.5] {zcurve2d}
	\caption{Построение Z-последовательности}
	\label{img:zcurve2d}
\end{figure}

Позволяет эффективно производить поиск по интервалам значений, однако часть возвращаемого результата может и не находиться в указанном интервале (рис.~\ref{img:zcurve2d_interval}), поэтому при запросе приходится применять дополнительные механизмы для фильтрации данных. Это накладывает некоторые ограничения на целесообразность применения данного индекса. Запросы должны быть.

\begin{itemize}
	\item \textbf{Часто задаваемыми}. Распространена практика, когда часть параметров запроса не задается, а остается открытой, однако в данном случае это может серьезно влиять на производительность.
	\item \textbf{<<Избирательным>>}. Границы, устанавливаемые при запросе должны исключать большие объемы данных. Для неравномерно распределенных логических значений пространство поиска может быть сильно увеличено.
\end{itemize}

\begin{figure}[ht] 
	\centering
	\includegraphics [scale=0.35] {zcurve2d_interval}
	\caption{Поиск значений в интервале}
	\label{img:zcurve2d_interval}
\end{figure}

При реализации Z-адрес рассматривается исключительно как битовая последовательность. Это значит, что единственное ограничение на тип ключа --- возможность упорядочивания при переходе к двоичному представлению. В итоге доступные типы ограничиваются не только целыми числами, но и числами с плавающей точкой, строками, временными метками...

Данный тип индексирование используется в TransBase\cite{ramsak2000integrating}, Accumulo, HBase \cite{nishimura2011md}, DynamoDB\cite{DynamoZorderP1, DynamoZorderP2}. 

Стоит отметить, что данное преобразование не является единственным для отображения многомерных данных в одномерные. Могут использоваться кривые Гильберта или Пеано. Однако Z-последовательность гораздо проще для вычисления.

\subsection{Индексы c использованием машинного обучения}
Можно выделить несколько подходов, которые могут быть использованы для поиска информации и выделения закономерностей в больших массивах данных --- Latent Semantic Indexing (LSI) и Hidden Markov Model (HMM). Данные варианты хоть и являются интересными и полезными в некоторых сферах, но примеров их использования в каких--либо СУБД нет.

\section{Используемые индексы в различных СУБД}
\begin{tabular}{|c|c|{c}}
	\hline
	СУБД & Индексы\\
	\hline
	PostgreSQL & B-Tree, R-Tree, Hash, GiST,\\ 
	& SP-GiST, GIN, RUM, BRIN, Bloom  \\
	MySQL/MariaDB & B-Tree, Hash, R-Tree, Inverted Index  \\
	Oracle &  B-Tree, B-Tree--cluster,\\
	& Hash--cluster, Reverse key, Bitmap\\
	MongoDB & B-Tree, Geohash, Text index, Hash \\
	OrientDB & SB-Tree, Hash, Lucene Fulltext, Lucene Spatial \\
	MemSQL & SkipList, Hash, Columnstore \\ \hline
\end{tabular}