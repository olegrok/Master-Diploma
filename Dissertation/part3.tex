\chapter{Реализация} \label{chapt3}

Реализацию индекса можно декомпозировать на несколько частей:
\begin{itemize}
	\item Битовый массив (bit array)
	\item Логика z-order curve
	\item Встраивание в движок БД
	\item Lua-frontend
\end{itemize}

\section{Bit array}
Как описано в предыдущих пунктах, индексируемое значение получается
в результате перемешивания битов указанных индексируемых полей.
Данную структуру будем называть битовый массив. При реализации прототипа
было решено найти и использовать готовую реализацию на языке С.
Реализация была найдена --- \url{https://github.com/noporpoise/BitArray},
она удовлетворяла необходимым функциональным потребностям, однако имела
достаточно небольшое покрытие тестами, содержала баги, которые пришлось
исправить --- \url{https://github.com/noporpoise/BitArray/pull/15} и
была достаточно неоптимальной с учетом специфики решаемой задачи.

С учетом того, что для хранения и представления
большинства типов используется $64$ бита, размер массива всегда будет
кратен $64$ элементам. А именно $N * 64$, где $N$ --- количество частей
в индексе. Приведенная выше реализация содержала достаточно большое
число проверок и занимала больше памяти из-за того,
что являлось массивом общего назначения с возможностью динамического
изменения размера.
Для достижения максимальной эффективности пришлось реализовать свой
битовый массив постоянного размера и более оптимально работающий с
памятью (для выделения памяти использовалось 2 системных вызова,
один --- выделение структуры со служебными полями, другой сам массив).
В полученной реализации создание массива --- одна аллокация.
Служебное поле "количество элементов в массиве" также потеряло смысл
и было удалено поскольку вычисляется как $N * 64$.

Следующий шаг в оптимизации --- <<векторизация>>.
Большинство современных процессоров поддерживает так называемые
векторные инструкции, служащие для обработки массивов данных
(SIMD --- — Single Instruction Multiple Data).
По словам разработчиков использование таких инструкций позволяет
получать прирост производительности до 30\%.
О том, что какой-то цикл может быть векторизован можно с
помощью директивы \textit{\#pragma simd},
однако это не дает гарантий, что цикл будет векторизован,
компилятор может и проигнорировать данную директиву, к тому же
большинство современных компиляторов могут автоматически находить
векторизуемые циклы. Посмотреть за тем, векторизуется цикл или нет,
можно с помощью специальных опций компилятора.

Циклы для операций AND и OR были векторизованы для компиляторов
GCC v7.4.0 и Apple Clang v11.0.0.
